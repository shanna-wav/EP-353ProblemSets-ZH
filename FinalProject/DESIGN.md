##Final Project Design Description

My program reads audio files, computes FFT data from this audio file, and organizes the resulting data into critical bands that have been defined by human hearing. Critical bands determine sensory consonant and dissonant pitches percieved by the human brain. 

This program uses the headers: stdio.h, stdlib.h, memory.h, math.h, string.h, and sndfile.h. Other files included are four different sine waves at the frequencies 250Hz, 500Hz, 1000Hz, 2000Hz. Additionally, there is a FinalResults.txt file that holds the data once the program runs. The main.c file holds the FFT function, the Partition function for the FFT, and the main function, which is all of the code in the program. Other files included are a presentation pdf document, preproposal, proprosal, and status folders, and README.md.

This program is compiled by using the command "clang main.c -o main -lsndfile". The sndfile.h header must be aquired from the libsndfile library. Instructions in the README.md describe how to install it. 

The first part of this program is the preprocessor definitions and a struct definition. The preprocessor definition BUFFERSIZE gives the buffersize, and the preprrocessor definition FILENAME gives the name of the audio file to be read. I put these two variables into preprocessor definitions so that they can easily be changed for differing results. The struct that I made is called `complex` and creates a complex number, holding a real and imaginary number together. This complex number is important because it is used when calculating the FFT. 

The first function is the partition function, which is a utility function that is needed to accomplish the "divide and conquer" algorithm for the FFT. This algorithm is also known as Cooley Turkey, and it reorganizes odd and even values into a temporary array so that the even values make up the first half of the array, and the odd values make up the last half of the array. The `floor` function ensures integer division throughout the function. Once the values are organized into the temporary array, they are replaced into the `inStart` array, which will hold the values for calculation.

The next function is the FFT function. Here, the partition function is implemented with the start and end of the buffer, once zero padding has ensured that there will be no memory errors, and that the recursion in this function will divide the values evenly. Through researching this project, I have learned that recursion is the best and fastest way to implement an FFT for the time allotted for this project. Then, the even and odd values are temporarily stored in complex structs, and a DFT complex struct holds the main expression, which involves Euler's formula. The dft values combine with the odd and even values and are reorganized into the buffer or `inStart`. 

The last function is the main function, where the FFT is implemented and the critical bands are organized. First, a sound file is created as well as a type complex pointer `buffer`. Next, an integery array called `bark` holds 25 values that represent the upper and lower limits of all of the barks, which is another term for the number range within a critical band. Then, a text file is created to store the numerical data from the program. The text file begins by reading some audio file information including samplerate and length of the audio file in samples. In order for the program to read the audio file with double values, I created a temporary buffer that holds the real and imaginary values of buffer as individual values so that the file is readable, and then the values are returned to the complex index of the original `buffer` array. 

In the next part of the main function, the FFT is implemented with a for loop in increments of the buffer size, which is currently set to 256. I created a temporary array called FFTresults which holds the results of the FFT for each frequency bin, and takes the average value of each bin afterwards. In the implementation of the FFT, I am only using the real value, which gives the frequency information, because I do not need the imaginary value, which gives the phase imformation. 

Next, the FFT values are ready to be organized into critical bands. I created a temporary array called barkout that stores the values going into the barks. Then, in a for loop, I assign the bin frequencies to the critical bandwidths using the formula 1/BUFFERSIZE * sample rate to determine the frequency of each FFT bin. Once a bark is filled, the dividend that finds the average FFT value in each bark is reset to zero. Finally, the results of the average energy in each bark is printed into the text file along with the FFT values at each frequency bin. The file and sound file is closed and arrays are freed. 